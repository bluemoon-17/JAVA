[부호/증감 연산자]
1. + 피연산자 - 피연산자의 부호 유지
2. - 피연산자 - 피연산자의 부호 변경

정수타입(byte, short, int)의 연산의 결과는 int 타입
- 부호를 변경하는 것 = 연산

{증감 연산자}
1. ++ - 1증가 {++ 피연산자 - 피연산자 1증가, 피연산자 ++ - 연산 수행 후 피연산자 값 1증가}
2. -- - 1감소 {-- 피연산자 - 피연산자 1감소, 피연산자 -- - 연산 수행 후 피연산자 값 1감소}


[산술 연산자]
1. + 덧셈 연산
2. - 뺄셈 연산
3. * 곱셈 연산
4. / 나눗셈 연산
5. % 나머지 연산

* 피연산자 = 정수타입, 결과 = int 타입
* 피연산자 중 하나가 long이면, 결과 = long
* 피연산자 중 하나가 실수타입 이면, 결과 = 실수


[오버플로우, 언더플로우]
1. 오버플로우 - 타입이 허용하는 최대값을 벗어나는 것
2. 언더플로우 - 타입이 허용하는 최소값을 벗어나는 것

*int 타입에서 오버, 언더 플로우가 될 가능성이 있다면, long타입으로 연산해야함


[정확한 계산은 정수 연산으로]

[나눗셈 연산 후 NaN, Infinity 처리
5 / 0, 5 % 0의 경우 예외 발생, 무한대의 값 정수 표현 불가
-> NaN, Infinity 처리됨 (이어서 연산 수행 X)

{결과가 무한대인지 확인하기}
Double.isInfinite(), Double.isNaN() 사용
-> 맞을 경우 True, 아닐경우 False 출력

[비교 연산자]
1. 동등 비교
- == (같은지 비교)
- != (다른지 비교)

2. 크기 비교
a > b - a가 큰지 검사
a >= b - a가 크거나 같은지 검사
a < b - b가 큰지 검사
a <= b - b가 크거나 같은지 검사

*문자열 비교시 - equals(), !equala() 사용


[논리 연산자]
1. AND(논리곱) &&, & - 피연산자 모두가 true일 경우에만 true
2. OR(논리곱) ||, | - 피연산자 중 하나만 true여도  true
3. XOR(논리곱) ^ - 피연산자 중 하나가 true, 나머지 하나는 false일 경우에만 true
4. NOT(논리곱) ! - 피연산자의 논리 값을 바꿈


[비트 논리 연산자]
-bit 단위로 논리 연산 수행
-2진수 0과1로 저장되는 정수(byte, short, int, long)만 피연산자 가능
-실수(double, float)은 피연산자 불가능

1. AND(논리곱) & - 두 비트 모두 1이여야 연산결과 1
2. OR(논리곱) | - 두 비트 중 하나만 1이면 연산결과 1
3. XOR(논리곱) ^ - 두 비트 중 하나는 1, 나머지 하나가 0일경우 연산결과 1
4. NOT(논리곱) ! - 보수

[비트 이동 연산자]
- 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산 수행
a << b - a의 각 비트를 b만큼 좌측으로 이동 = a x 2의 b제곱
a >> b - a의 각 비트를 b만큼 우측으로 이동 = a /2의 b제곱
a>>>b - a의 각 비트를 b만큼 우측으로 이동

[대입 연산자]
-우측 피연산자 값을 좌측 피연산자에 대입

=, 우측 피연산자 값을 변수에 저장

+= - 변수 = 변수 + 피연산자
-= - 변수 = 변수 - 피연산자
*= - 변수 = 변수 * 피연산자
/= - 변수 = 변수 / 피연산자
%= - 변수 = 변수 % 피연산자
&= - 변수 = 변수 & 피연산자
|= - 변수 = 변수 | 피연산자
^= - 변수 = 변수 ^ 피연산자
<<= - 변수 = 변수 << 피연산자
>>= - 변수 = 변수 >> 피연산자
>>>= - 변수 = 변수 >>>피연산자


[삼항 연산자]
(피연산자? 피연산자: 피연산자)
true일 경우 - :앞 피연산자 선택
false 일 경우 - :뒤 피연산자 선택

[연산 방향과 순위]
